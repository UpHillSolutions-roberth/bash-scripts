#!/bin/bash

# Source the utilities file
source "$(dirname "$0")/bash_utilities"

# Clean Up
cleanup() {
  print_title "CLEANING UP"
  dunstify -C "$PROGRESS_ID"
  rm -f "$TEMP_FILE"
  TOTAL_UPDATES=$(( ${DNF_COUNT:-0} + ${FLATPAK_COUNT:-0} ))
  if (( TOTAL_UPDATES <= 0 )); then
    echo "No updates found, deleting log file." 
    rm -f "$LOG_FILE"
  else 
    echo "$TOTAL_UPDATES packages were updated. Log file: file://$LOG_FILE"
    if [ -f /var/run/reboot-required ]; then
      printf "${ORANGE}Reboot required to apply updates.${NC}\n"
    fi
  fi
}

# Function to handle terminal actions
give_terminal_exit_choices() {
  echo
  echo "What would you like to do next?"
  if [ "$NEEDS_REBOOT" = true ]; then
    printf "${ORANGE}A system reboot is required to apply all updates.${ENDL}"
  fi
  printf "${BLUE}1. Reboot${ENDL}"
  printf "${BLUE}2. Power-off${ENDL}"
  printf "${GREEN}3. Exit (Done)${ENDL}"
  exec < /dev/tty
  read -p "Enter your choice [1-3] (default is 3): " CHOICE
  CHOICE=${CHOICE:-3}
  case $CHOICE in
    1) printf "${GREEN}Rebooting system${ENDL}"; sudo reboot ;;
    2) printf "${GREEN}Powering off system${ENDL}"; sudo poweroff ;;
    3) printf "${GREEN}Exiting script${ENDL}" ;;
    *) printf "${RED}Invalid choice. Please choose 1, 2, or 3.${ENDL}" ;;
  esac
}

# Function to handle notification actions
give_notification_exit_choices() {
  # Check if reboot is required
  if [ "$NEEDS_REBOOT" = true ]; then
    ICON="system-reboot"
    REBOOT_MESSAGE="\nA system reboot is required to apply all updates."
  else 
    ICON="mintupdate-up-to-date"
    REBOOT_MESSAGE=""
  fi

  # Show notification
  PROGRESS_ID=$(dunstify -a "System Update" -r "$PROGRESS_ID" -t 0 -i $ICON \
    --action="open,ðŸ“‚ View Logs" \
    --action="reboot,ðŸ”„ Reboot" \
    --action="shutdown,ðŸ’¡ Power-off" \
    "Update Complete" "$RESULT$REBOOT_MESSAGE" | tail -n1)
  case "$PROGRESS_ID" in
    "open") xdg-open "$LOG_DIR" ;;
    "reboot") printf "${GREEN}Rebooting system...${ENDL}"; sudo reboot ;;
    "shutdown") printf "${GREEN}Powering off system${ENDL}"; sudo poweroff ;;
    *) printf "${GREEN}Exiting script.${ENDL}" ;;
  esac
}

# Function to display help information
show_help() {
  print_title "HELP INFORMATION"
  print_header "Usage: $(basename "$0") [OPTIONS]"
  printf "This script performs a comprehensive system update on Fedora, including DNF package updates, security updates,\n"
  printf "cleanup of old packages, updating Flatpak packages, and cleaning up cached package data.\n\n"

  print_header "Options:"
  printf "  ${BOLD}${BLUE}-s, --skip-security${NC}        Skip security updates.\n"
  printf "  ${BOLD}${BLUE}-f, --skip-flatpak${NC}         Skip Flatpak updates.\n"
  printf "  ${BOLD}${BLUE}-c, --skip-clean-cache${NC}     Skip cleaning the DNF cache.\n"
  printf "  ${BOLD}${BLUE}-n, --no-confirm${NC}           Run DNF commands without the '-y' flag to require user confirmation.\n"
  printf "  ${BOLD}${BLUE}-h, --help${NC}                 Display this help message.\n\n"

  print_header "Examples:"
  local cmd=$(basename "$0")
  printf "  ${BLUE}${cmd}${NC}                      Run the script to perform system updates with auto-confirmation.\n"
  printf "  ${BLUE}${cmd} -s${NC}                   Perform system updates without checking for security updates.\n"
  printf "  ${BLUE}${cmd} -f${NC}                   Perform system updates without updating Flatpak packages.\n"
  printf "  ${BLUE}${cmd} -c${NC}                   Perform system updates without cleaning the DNF cache.\n"
  printf "  ${BLUE}${cmd} -n${NC}                   Perform system updates with user confirmation for each DNF operation.\n"
  printf "  ${BLUE}${cmd} -s -f -c${NC}             Combine multiple options to skip security updates, Flatpak updates, and DNF cache cleaning.\n"
  
  exit 0
}

# Default values for options
SKIP_SECURITY=false
SKIP_FLATPAK=false
SKIP_CLEAN_CACHE=false
AUTO_CONFIRM=true

# Parse command line arguments
while [[ "$#" -gt 0 ]]; do
  case "$1" in
    -s|--skip-security) SKIP_SECURITY=true ;;
    -f|--skip-flatpak) SKIP_FLATPAK=true ;;
    -c|--skip-clean-cache) SKIP_CLEAN_CACHE=true ;;
    -n|--no-confirm) AUTO_CONFIRM=false ;;
    -h|--help) show_help ;;
    *) printf "${RED}Unknown option: $1${ENDL}"; show_help ;;
  esac
  shift
done

# Set DNF flags
DNF_FLAGS=""
[[ "$AUTO_CONFIRM" == true ]] && DNF_FLAGS="-y"

# Handle exit signals
trap 'printf "${RED}Update interrupted! Cleaning up...${ENDL}"; cleanup; exit 1' SIGINT SIGTERM
trap 'printf "${BLUE}Exiting script.${ENDL}"; cleanup; exit 0' EXIT

# Check for and install necessary dependencies
MISSING_PACKAGES=()
for pkg in rpmconf flatpak remove-retired-packages; do
  if ! command -v "$pkg" &> /dev/null; then
    MISSING_PACKAGES+=("$pkg")
  fi
done
if [ ${#MISSING_PACKAGES[@]} -gt 0 ]; then
  echo "Installing missing dependencies: ${MISSING_PACKAGES[*]}"
  sudo dnf install $DNF_FLAGS "${MISSING_PACKAGES[@]}"
fi

# Start system updates
print_title "STARTING SYSTEM UPDATES"
{
  ICON="mintupdate-checking"
  PROGRESS_ID=$(dunstify -a "System Update" -p -t 0 "System Update" "Starting system update...")

  # Begin logging
  LOG_DIR="$HOME/logs"
  mkdir -p "$LOG_DIR"
  LOG_FILE="$LOG_DIR/system_update_$(date +%F_%H-%M-%S).log"
  exec > >(tee -a "$LOG_FILE") 2>&1

  # Refresh DNF cache
  if [ "$SKIP_CLEAN_CACHE" = false ]; then
    print_header "Refreshing DNF Cache"
    dunstify -a "System Update" -r "$PROGRESS_ID" -t 0 -i $ICON "System Update" "Refreshing DNF cache..."
    sudo dnf makecache --refresh $DNF_FLAGS
  fi
}

# Handle DNF Updates
print_header "Checking DNF Pending Updates"
{
  dunstify -a "System Update" -r "$PROGRESS_ID" -t 0 -i $ICON "System Update" "Checking for DNF updates..."
  DNF_PENDING=$(dnf check-update | grep -c '^[a-zA-Z]')
  ICON="mintupdate-installing"
  if (( DNF_PENDING > 0 )); then
    print_header "Updating DNF Packages"
    dunstify -a "System Update" -r "$PROGRESS_ID" -t 0 -i $ICON "System Update" "Updating $DNF_PENDING DNF Packages..."
    TEMP_FILE=$(mktemp)
    script -q -c "sudo dnf update $DNF_FLAGS" "$TEMP_FILE"
    DNF_OUTPUT=$(sed '1d;$d' "$TEMP_FILE")
    DNF_COUNT=$(echo "$DNF_OUTPUT" | grep -cE 'Upgraded|Installed|Updated|Reinstalled')
    dunstify -a "System Update" -r "$PROGRESS_ID" -t 0 -i $ICON "System Update" "DNF update completed. Updated $DNF_COUNT packages."
    rm "$TEMP_FILE"
  else
    DNF_COUNT=0
    dunstify -a "System Update" -r "$PROGRESS_ID" -t 0 -i $ICON "System Update" "No DNF updates found."
    echo "Nothing to do."
  fi
}


# Handle leftover RPM configuration files
print_header "Handling Leftover RPM Configuration Files"
{
  dunstify -a "System Update" -r "$PROGRESS_ID" -t 0 -i $ICON "System Update" "Handling RPM configuration files..."
  RPM_FILES=$(sudo rpmconf -a | tee /dev/tty)
  if [ -n "$RPM_FILES" ]; then
    echo "$RPM_FILES"
  else 
    echo "Nothing to do."
  fi
}


# Check and install security updates
if [ "$SKIP_SECURITY" = false ]; then
  print_header "Security Updates"
  dunstify -a "System Update" -r "$PROGRESS_ID" -t 0 -i $ICON "System Update" "Checking for security updates..."
  SECURITY_UPDATES=$(sudo dnf check-update --security)
  if echo "$SECURITY_UPDATES" | grep -q "Security"; then
    sudo dnf update --security $DNF_FLAGS
    dunstify -a "System Update" -r "$PROGRESS_ID" -t 0 "System Update" "Installed security updates."
  else 
    echo "Nothing to do."
  fi
fi

# Clean up old packages
print_header "Cleaning Up Old Packages"
{
  dunstify -a "System Update" -r "$PROGRESS_ID" -t 0 -i $ICON "System Update" "Cleaning up old packages..."
  AUTO_REMOVE=$(sudo dnf autoremove $DNF_FLAGS)
  if ! echo "$AUTO_REMOVE" | grep -q "Nothing to do"; then
    echo "Nothing to do."
  else 
    echo "$AUTO_REMOVE"
  fi
}


# Handle Flatpak updates
if [ "$SKIP_FLATPAK" = false ]; then
  print_header "Checking Flatpak Updates"
  FLATPAK_PENDING=$(flatpak remote-ls --updates | wc -l)
  if [ "$FLATPAK_PENDING" -gt 0 ]; then
    print_header "Updating Flatpak Packages"
    dunstify -a "System Update" -r "$PROGRESS_ID" -t 0 -i $ICON "System Update" "Updating $FLATPAK_PENDING Flatpak packages..."
    FLATPAK_OUTPUT=$(flatpak update -y $DNF_FLAGS)
    FLATPAK_COUNT=$(echo "$FLATPAK_OUTPUT" | grep -c "Updated:")
    dunstify -a "System Update" -r "$PROGRESS_ID" -t 0 -i $ICON "System Update" "Flatpak update completed. Updated packages: $FLATPAK_COUNT"
  else 
    echo "Nothing to do."
    FLATPAK_COUNT=0
  fi
  print_header "Removing Unused Flatpak Packages"
  dunstify -a "System Update" -r "$PROGRESS_ID" -t 0 -i $ICON "System Update" "Removing unused Flatpak packages..."
  flatpak uninstall --unused -y $DNF_FLAGS
fi

# Handle driver or kernel updates
if (( DNF_COUNT > 0 )); then
  print_header "Checking for Driver or Kernel Changes"
  dunstify -a "System Update" -r "$PROGRESS_ID" -t 0 -i $ICON "System Update" "Checking for driver or kernel updates..."
  HAS_NVIDIA=$(echo "$DNF_OUTPUT" | grep -q -i 'nvidia')
  HAS_KERNEL=$(echo "$DNF_OUTPUT" | grep -q -i 'kernel')
  if echo "$DNF_OUTPUT" | grep -qi 'font'; then
    echo "Font packages were updated. Rebuilding font cache..."
    fc-cache -fv
  fi
  if [ "$HAS_NVIDIA" = true ] || [ "$HAS_KERNEL" = true ]; then
    dunstify -a "System Update" -r "$PROGRESS_ID" -t 0 -i $ICON "System Update" "Driver and/or kernel update detected. Performing maintenance..."
    if [ "$HAS_NVIDIA" = true ]; then
      echo "NVIDIA package updates detected."
      echo "Refreshing akmods..."
      sudo akmods --force
    elif [ "$HAS_KERNEL" = true ]; then
      echo "Kernel package updates detected."
    fi
    echo "Performing dracut..."
    sudo dracut --force
    echo "Completed dracut!"
    dunstify -a "System Update" -r "$PROGRESS_ID" -t 0 -i $ICON "System Update" "Completed maintenance."
  fi
fi

# Handle finished updates
echo
print_title "SYSTEM UPDATES COMPLETED"
{
  TOTAL_UPDATES=$(( ${DNF_COUNT:-0} + ${FLATPAK_COUNT:-0} ))
  NEEDS_REBOOT=$([ -f /var/run/reboot-required ] && printf true || printf false)
  if (( TOTAL_UPDATES <= 0 )); then
    RESULT="No updates found."
    rm "$LOG_FILE"
  else
    RESULT="$TOTAL_UPDATES packages were updated successfully!"
    # Show log file
    print_header "Log File Saved"
    {
      echo "Open Log directory: file://$LOG_DIR"
      echo "View Log file: file://$LOG_FILE"
      echo
    }
  fi

  # Start listening to user input
  give_notification_exit_choices & 
  give_terminal_exit_choices &
  wait -n
}